package com.chillbilling.controller;

import com.chillbilling.dto.InvoiceNumberRequest;
import com.chillbilling.dto.PaymentRecord;
import com.chillbilling.entity.Payment;
import com.chillbilling.entity.User;
import com.chillbilling.service.PaymentService;
import com.chillbilling.service.UserService;
import com.razorpay.Order;
import com.razorpay.RazorpayClient;
import com.razorpay.RazorpayException;
import com.razorpay.Utils;

import jakarta.validation.Valid;

import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/payments")
public class PaymentController {
	
	 @Autowired
	    private RazorpayClient razorpayClient;
	
    private final PaymentService paymentService;
    private final UserService userService;

    public PaymentController(PaymentService paymentService, UserService userService) {
        this.paymentService = paymentService;
        this.userService = userService;
    }

   

    @Value("${razorpay.keyId}")
    private String razorpayKeyId;

    @Value("${razorpay.webhookSecret}")
    private String webhookSecret;

    // --- Helpers to map Razorpay -> your enums ---
    private Payment.Status mapStatus(String razorpayStatus) {
        if (razorpayStatus == null) return Payment.Status.FAILED;
        switch (razorpayStatus.toLowerCase()) {
            case "captured": 
                return Payment.Status.SUCCESS;
            case "authorized": 
                return Payment.Status.PENDING; 
            case "pending":  
                return Payment.Status.PENDING;
            case "failed":   
                return Payment.Status.FAILED;
            default:         
                return Payment.Status.FAILED;
        }
    }


    private Payment.Method mapMethod(String razorpayMethod) {
        if (razorpayMethod == null) return Payment.Method.CASH; // fallback
        switch (razorpayMethod.toLowerCase()) {
            case "upi":        return Payment.Method.UPI;
            case "netbanking": return Payment.Method.BANK_TRANSFER;
            case "card":       return Payment.Method.CREDIT_CARD; // (you can refine to DEBIT vs CREDIT if needed)
            case "qr":         return Payment.Method.QR;
            case "wallet":     return Payment.Method.UPI;         // or extend enum with WALLET
            default:           return Payment.Method.CASH;        // fallback
        }
    }

    // 1) Create Razorpay order (no DB storage; attach invoiceNumber in notes)
    @PreAuthorize("hasRole('CUSTOMER')")
    @PostMapping("/create-order")
    public Map<String, Object> createOrder(@RequestBody Map<String, Object> requestData) throws RazorpayException {
        // Expecting rupees from frontend, e.g. { "amount": 499.00, "invoiceNumber": "INV123456" }
        // (If you want to compute from invoice balance server-side, say the word and I’ll wire that in.)
        Number amountRupeesNum = (Number) requestData.get("amount");
        if (amountRupeesNum == null) {
            throw new IllegalArgumentException("amount (in rupees) is required");
        }
        BigDecimal amountRupees = new BigDecimal(amountRupeesNum.toString());
        if (amountRupees.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("amount must be > 0");
        }

        String invoiceNumber = requestData.get("invoiceNumber") != null
                ? requestData.get("invoiceNumber").toString()
                : null;

        // Convert to paise (integer)
        long amountPaise = amountRupees.multiply(BigDecimal.valueOf(100)).setScale(0, BigDecimal.ROUND_HALF_UP).longValue();

        JSONObject options = new JSONObject();
        options.put("amount", amountPaise);         // paise
        options.put("currency", "INR");
        options.put("receipt", "txn_" + System.currentTimeMillis());

        // attach notes so webhook can link back to your invoice
        JSONObject notes = new JSONObject();
        if (invoiceNumber != null) notes.put("invoiceNumber", invoiceNumber);
        options.put("notes", notes);

        Order order = razorpayClient.orders.create(options);

        Map<String, Object> response = new HashMap<>();
        response.put("orderId", order.get("id"));
        response.put("currency", "INR");
        response.put("amount", amountPaise);
        response.put("key", razorpayKeyId); // frontend needs this for Razorpay Checkout
        response.put("invoiceNumber", invoiceNumber);
        return response;
    }

    // 2) Webhook (no auth; protect with signature)
    @PostMapping("/webhook")
    public ResponseEntity<String> handleWebhook(
            @RequestBody String payload,
            @RequestHeader("X-Razorpay-Signature") String signature) {

        try {
            boolean isValid = Utils.verifyWebhookSignature(payload, signature, webhookSecret);
            if (!isValid) {
                return ResponseEntity.status(400).body("Invalid signature");
            }

            JSONObject root = new JSONObject(payload);
            String event = root.optString("event", "");
            // We’ll react to payment.* events
            JSONObject paymentEntity = root.getJSONObject("payload")
                                           .getJSONObject("payment")
                                           .getJSONObject("entity");

            String razorpayPaymentId = paymentEntity.optString("id", null);
            String razorpayStatus    = paymentEntity.optString("status", null);  // captured/failed/pending
            String razorpayMethod    = paymentEntity.optString("method", null);  // upi/card/netbanking/qr/wallet...
            long amountPaise         = paymentEntity.optLong("amount", 0L);

            // Get invoiceNumber from notes (you set it in createOrder; also set it in frontend Checkout options if you wish)
            String invoiceNumber = null;
            if (paymentEntity.has("notes")) {
                JSONObject notes = paymentEntity.getJSONObject("notes");
                invoiceNumber = notes.optString("invoiceNumber", null);
            }

            // If we can't link to an invoice, we can’t record it in your system safely
            if (invoiceNumber == null || invoiceNumber.isBlank()) {
                // You may log and ignore, or add a fallback if you want to store orphan payments.
                return ResponseEntity.ok("IGNORED_NO_INVOICE_NUMBER");
            }

            Payment.Status status = mapStatus(razorpayStatus);
            Payment.Method method = mapMethod(razorpayMethod);

            // Only store finalized (SUCCESS/FAILED). PENDING can be ignored or stored—your call.
            if (status == Payment.Status.SUCCESS 
            	    || status == Payment.Status.FAILED 
            	    || status == Payment.Status.PENDING) {
                PaymentRecord record = new PaymentRecord();
                record.setInvoiceNumber(invoiceNumber);
                record.setAmount(amountPaise / 100.0); // convert to rupees
                record.setMethod(method);
                record.setStatus(status);
                record.setTransactionId(razorpayPaymentId);
                // paymentDate left null -> PaymentService sets now() if null, or you can parse created_at
                System.out.println("Webhook Event: " + event 
                	    + ", Status: " + status 
                	    + ", Invoice: " + invoiceNumber 
                	    + ", TxnId: " + razorpayPaymentId);

                paymentService.recordPayment(record); // this validates amounts & duplicate txn id
            }

        } catch (Exception e) {
            // Log the payload if needed for debugging
            return ResponseEntity.badRequest().body("FAILURE");
        }

        return ResponseEntity.ok("SUCCESS");
    }



    // Record a payment (ADMIN or ACCOUNTANT)
    @PreAuthorize("hasAnyRole('ADMIN', 'ACCOUNTANT')")
    @PostMapping
    public ResponseEntity<String> recordPayment(@Valid @RequestBody PaymentRecord record) {
        paymentService.recordPayment(record);
        return ResponseEntity.ok("Payment recorded successfully");
    }

    // Get all payments (ADMIN or ACCOUNTANT)
    @PreAuthorize("hasAnyRole('ADMIN', 'ACCOUNTANT')")
    @GetMapping
    public List<Payment> getAllPayments() {
        return paymentService.getAllPayments();
    }

    // Get payments by invoice number (ADMIN or ACCOUNTANT)
    @PreAuthorize("hasAnyRole('ADMIN', 'ACCOUNTANT')")
    @PostMapping("/by-invoice")
    public List<Payment> getPaymentsByInvoiceNumber(@RequestBody InvoiceNumberRequest request) {
        return paymentService.getPaymentsByInvoiceNumber(request.getInvoiceNumber());
    }

    // Get current customer’s payment history
    @PreAuthorize("hasRole('CUSTOMER')")
    @GetMapping("/my")
    public List<Payment> getCurrentCustomerPayments(Authentication auth) {
        User loggedInUser = userService.getUserByIdentifier(auth.getName());
        String email = loggedInUser.getEmailId();
        return paymentService.getPaymentsByCustomerEmail(email);
    }
    
    // Customer fetch payments for specific invoice belongs to same customer
    @PreAuthorize("hasRole('CUSTOMER')")
    @PostMapping("/my-invoice-payments")
    public List<Payment> getMyPaymentsByInvoiceNumber(
            Authentication auth,
            @RequestBody InvoiceNumberRequest request
    ) {
        User loggedInUser = userService.getUserByIdentifier(auth.getName());
        String invoiceNumber = request.getInvoiceNumber();

        boolean ownsInvoice = paymentService.invoiceBelongsToCustomer(invoiceNumber, loggedInUser.getEmailId());
        if (!ownsInvoice) {
            throw new SecurityException("You are not authorized to view payments for this invoice.");
        }

        return paymentService.getPaymentsByInvoiceNumber(invoiceNumber);
    }
}
